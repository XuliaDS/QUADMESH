int EG_createMeshMap(bodyQuad *bodydata)
{
    int          f, stat = 0, stat2 = 0, j, q, k, kk, kOK, len;
    int          ntri, nquad, e4[4] ;
    const int    *tris, *tric, *ptype, *pindex;
    double       angle;
    const double *xyzs, *uvs;
    int          qV[6]    = { 0, 1, 2, 5, 0, 1};
    int          qLoop[5] = { 0, 1, 2, 3, 0   };
    ego          tess;
    egTessel     *btess;

    tess  = bodydata->tess;
    btess = (egTessel *) tess->blind;

    bodydata->qm = (meshMap **) EG_alloc(bodydata->nfaces * sizeof(meshMap *));
    if (bodydata->qm == NULL) return  EGADS_MALLOC;
    for (f = 0; f < bodydata->nfaces; ++f) {
        bodydata->qm[f] = (meshMap *) EG_alloc(sizeof(meshMap));
        if (bodydata->qm[f] == NULL) {
            printf("Create Quad Map: MALLOC error!! \n ");
            stat2 = EGADS_MALLOC;
            continue;
        }
        bodydata->qm[f]->fID       = f + 1;
        bodydata->qm[f]->plotcount = 0;
        /* Edges associated to face */
        stat = EG_getTessFace(bodydata->tess, f + 1, &len,
                              &xyzs, &uvs, &ptype, &pindex, &ntri,
                              &tris, &tric);
        if (stat != EGADS_SUCCESS) {
            printf("EG_createMeshMap :: EG_getTessFace %d !!\n", stat);
            stat2 = stat;
            continue;
        }
        nquad = (int) ntri/2;
        bodydata->qm[f]->oriV    = len;
        bodydata->qm[f]->oriQ    = nquad;
        bodydata->qm[f]->sizeV   = 2 * len;
        bodydata->qm[f]->sizeQ   = 2 * nquad;
        bodydata->qm[f]->totV    = len;
        bodydata->qm[f]->totQ    = nquad;
        bodydata->qm[f]->qInv    = NULL;
        bodydata->qm[f]->regBd0  = 1;
        if( btess->tess2d[f].tfi == 1) {
            bodydata->qm[f]->xyzs    = NULL;
            bodydata->qm[f]->uvs     = NULL;
            bodydata->qm[f]->vType   = NULL;
            bodydata->qm[f]->qIdx    = NULL;
            bodydata->qm[f]->qAdj    = NULL;
            bodydata->qm[f]->remQ    = NULL;
            bodydata->qm[f]->remV    = NULL;
            bodydata->qm[f]->valence = NULL;
            bodydata->qm[f]->star    = NULL;
            bodydata->qm[f]->fID     = 0;
            continue;
        }
        bodydata->qm[f]->xyzs    = (double *) EG_alloc(3*(2 * len  )*sizeof(double));
        bodydata->qm[f]->uvs     = (double *) EG_alloc(2*(2 * len  )*sizeof(double));
        bodydata->qm[f]->vType   = (int    *) EG_alloc(  (2 * len  )*sizeof(  int ));
        bodydata->qm[f]->qIdx    = (int    *) EG_alloc(4*(2 * nquad)*sizeof(  int ));
        bodydata->qm[f]->qAdj    = (int    *) EG_alloc(4*(2 * nquad)*sizeof(  int ));
        bodydata->qm[f]->remQ    = (int    *) EG_alloc(  (2 * nquad)*sizeof(  int ));
        bodydata->qm[f]->remV    = (int    *) EG_alloc(  (2 * len  )*sizeof(  int ));
        bodydata->qm[f]->valence = (int   **) EG_alloc(  (2 * len  )*sizeof(  int*));
        bodydata->qm[f]->star    = (vStar **) EG_alloc(  (2 * len  )*sizeof(vStar*));
        if (bodydata->qm[f]->qIdx  == NULL || bodydata->qm[f]->qAdj    == NULL ||
            bodydata->qm[f]->xyzs  == NULL || bodydata->qm[f]->uvs     == NULL ||
            bodydata->qm[f]->vType == NULL || bodydata->qm[f]->remQ    == NULL ||
            bodydata->qm[f]->remV  == NULL || bodydata->qm[f]->valence == NULL ||
            bodydata->qm[f]->star  == NULL) {
            stat2 = EGADS_MALLOC;
            continue;
        }
        bodydata->qm[f]->remQ[0]  = 0;
        bodydata->qm[f]->remV[0]  = 0;
        bodydata->qm[f]->invsteps = 0;
        for (j = 0; j < 2 * len; j++) {
            bodydata->qm[f]->star[j]    = NULL;
            bodydata->qm[f]->valence[j] = (int *) EG_alloc(3 * sizeof(int));
            if (bodydata->qm[f]->valence[j] == NULL) {
                stat2 = EGADS_MALLOC;
                continue;
            }
            bodydata->qm[f]->valence[j][2] = 0;
        }
        bodydata->qm[f]->face = bodydata->faces[f];
        stat   = EG_getRange(bodydata->qm[f]->face, bodydata->qm[f]->range, &j);
        for (j = 0; j < len; j++) {
            bodydata->qm[f]->vType  [j]         = ptype[j];
            bodydata->qm[f]->uvs    [2 * j    ] = uvs[2 * j    ];
            bodydata->qm[f]->uvs    [2 * j + 1] = uvs[2 * j + 1];
            if (uvs[2 * j    ] < bodydata->qm[f]->range[0] - 1.e-6 ||
                uvs[2 * j    ] > bodydata->qm[f]->range[1] + 1.e-6 ||
                uvs[2 * j + 1] < bodydata->qm[f]->range[2] - 1.e-6 ||
                uvs[2 * j + 1] > bodydata->qm[f]->range[3] + 1.e-6) {
                printf(" EG_createMeshMap :: vertex %d = %f  %f  is out of range !! \n ",
                       j + 1, uvs[2 * j], uvs[2 * j + 1]);
                printf(" Range FACE %d --- > %f  %f  %f  %f\n ", bodydata->qm[f]->fID,
                       bodydata->qm[f]->range[0],bodydata->qm[f]->range[1],
                        bodydata->qm[f]->range[2],bodydata->qm[f]->range[3]);
                stat2 = EGADS_INDEXERR;
                break;
            }
            bodydata->qm[f]->xyzs[3 * j    ] = xyzs[3 * j    ];
            bodydata->qm[f]->xyzs[3 * j + 1] = xyzs[3 * j + 1];
            bodydata->qm[f]->xyzs[3 * j + 2] = xyzs[3 * j + 2];
        }
        if (stat2 != EGADS_SUCCESS) continue;
        for (j = 0; j < nquad; j++)
            for (k = 0; k < 4; ++k) {
                bodydata->qm[f]->qIdx[4*j + k] = tris[6*j + qV[k+1]];
            }
        for (j = 0; j < nquad; j++)
        {
            kk  = 0;
            kOK = 0;
            q   = 0;
            while (q < nquad) {
                if (q == j) {
                    if (j == nquad - 1 && kk < 4) {
                        bodydata->qm[f]->qAdj[4*j + kk++] = -1;
                        if (kk == 4) break;
                        q = 0;
                    }
                    else q++;
                }
                if  (q == nquad) break;
                for (k = 0; k < 4; ++k) {
                    if ((bodydata->qm[f]->qIdx[4*j + qLoop[kk    ]] ==
                         bodydata->qm[f]->qIdx[4*q + qLoop[k     ]] ||
                         bodydata->qm[f]->qIdx[4*j + qLoop[kk    ]] ==
                         bodydata->qm[f]->qIdx[4*q + qLoop[k  + 1]]) &&
                            (bodydata->qm[f]->qIdx[4*j + qLoop[kk + 1]] ==
                             bodydata->qm[f]->qIdx[4*q + qLoop[k     ]] ||
                             bodydata->qm[f]->qIdx[4*j + qLoop[kk + 1]] ==
                             bodydata->qm[f]->qIdx[4*q + qLoop[k  + 1]])) {
                        bodydata->qm[f]->qAdj[4*j + kk++] = q + 1;
                        q   = -1;
                        kOK =  1;
                        k   =  4;
                        if (kk == 4) q = nquad;
                    }
                }
                if ((kOK == 0) && (q >= nquad -1)) {
                    bodydata->qm[f]->qAdj[4*j + kk++] = -1;
                    q = -1;
                    if (kk == 4) break;
                }
                else kOK = 0;
                q++;
            }
            if (kOK == 0 && kk < 4) {
                while (kk < 4)
                    bodydata->qm[f]->qAdj[4*j + kk++] = -1;
            }
        }
        for (j = 0; j < nquad; j++) {
            for (q = 0; q < 4; ++q)
                bodydata->qm[f]->valence[bodydata->qm[f]->qIdx[4 * j + q] - 1][0] = j + 1;
        }
        for (j = 0; j < len; j++) {
            stat = setValence (bodydata->qm[f], j + 1);
            if (stat != EGADS_SUCCESS) {
                printf("In EG_createMeshMap :: set valence at %d is %d!!\n ",
                       j + 1, stat);
                stat2 = stat;
                break;
            }
        }
        for (e4[0]= e4[1] = j = 0; j < len; j++) {
            if (bodydata->qm[f]->vType[j] == -1) continue;
            stat      = EG_angAtBdVert(bodydata->qm[f], j + 1, e4, &angle);
            if (stat != EGADS_SUCCESS || angle < EPS08 ) {
                printf(" FACE %d EG_angAtBdVert %d angle %f\n ",f + 1, stat, angle);
                printf(" Vertices: %d %d %d \n ", j+ 1, e4[0], e4[1]);
                if (bodydata->qm[f]->vType[j] == 0)
                  bodydata->qm[f]->vType[j] = 2;
            }
            else if (angle < 0.85 * PI) bodydata->qm[f]->vType[j] = 2;
            else if (angle < 1.25 * PI) bodydata->qm[f]->vType[j] = 3;
            else if (angle < 1.85 * PI) bodydata->qm[f]->vType[j] = 4;
            else                        bodydata->qm[f]->vType[j] = 5;
            if (bodydata->qm[f]->valence[j][2] < bodydata->qm[f]->vType[j])
                bodydata->qm[f]->vType[j] = bodydata->qm[f]->valence[j][2];
            if (bodydata->qm[f]->vType[j] == 2)
                bodydata->qm[f]->valence[j][1] = bodydata->qm[f]->valence[j][2] + 2; //adjusted based on vertex type, eg, a corner is regular when val = 2
            else if (bodydata->qm[f]->vType[j] == 3)
                bodydata->qm[f]->valence[j][1] = bodydata->qm[f]->valence[j][2] + 1;
            else if (bodydata->qm[f]->vType[j] >= 5)
                bodydata->qm[f]->valence[j][1] = bodydata->qm[f]->valence[j][2] - 1;
        }
        if (stat2 != EGADS_SUCCESS) {
            bodydata->qm[f]->fID = 0; // don't touch this face
            continue;
        }
    }
    return stat2;
}
