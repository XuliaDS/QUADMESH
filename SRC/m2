static int EG_vertexArea2(meshMap *qm, int vID)
{
  int s, i, k, k1, vA, vB, vC, vD, count, doublet, qV[4], ori[4], bv[4], lr[2], bvp, iv = -1;
  int selfint = 1, cw, s1, s2, totArea = 0;
  double cross[3], vn[6], vAB[3], vAC[3], vAD[3], tria[8], vr[2], lambda, dotNP;
  double c, pV[12], ang[4], qa[2], pen = 1.0, ma = 0.0, maiv = 0.0,mba = 0.0;

  for (s = 0; s < qm->star[vID-1]->nQ; s++) {
      qm->star[vID-1]->area [s]    = QA0;
      qm->star[vID-1]->ratio[s]    = 1.0;
      qm->star[vID-1]->angle[s]    = PI * 0.5;
      if(qm->star[vID-1]->quads[s] == -1) continue;
      EG_quadSize(qm, qm->star[vID-1]->quads[s], tria );
#ifdef DEBUG2
      printf(" TRIAREAS %lf %lf  %lf  %lf  \n", tria[0], tria[2], tria[1], tria[3]);
#endif
      qV[0] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 )    ] - 1;
      qV[1] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 1] - 1;
      qV[2] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 2] - 1;
      qV[3] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 3] - 1;
      // project coordinates
      selfint =  1;
      iv      = -1;
      mba     = ma = maiv = 0.0;
      bvp     = 0;
      for (doublet = count = k = 0; k < 4; ++k) {
          ori [k]  =  1;
          ang [k]  =  0.0;
          if (qV[k] + 1 == vID) iv = k;
          if (qm->valence[qV[k]][2] * qm->vType[qV[k]] == -2) {
              ori[k]  = 1;
              doublet = 1;
          } else {
              vA =  k;
              vB = (k + 1)%4;
              vC = (k + 2)%4;
              vD = (k + 3)%4;
              if (EG_angAtNPlane(qm, qV[vA] + 1, qV[vB] + 1, qV[vD] + 1,
                                 vn, &ang[k]) != EGADS_SUCCESS ) {
                                   selfint = 1;
                                   break;
              }
              c  = vn[0] * vn[3] + vn[1] * vn[4] + vn[2] * vn[5];
              for (i = 0; i < 4; i++) {
                k1     = qV[(k + i)%4];
                dotNP  = vn[0] * qm->xyzs[3 * k1    ]+
                         vn[1] * qm->xyzs[3 * k1 + 1]+
                         vn[2] * qm->xyzs[3 * k1 + 2];
                lambda = (c - dotNP);
                pV[3 * i    ] = qm->xyzs[3 * k1    ] + lambda * vn[0];
                pV[3 * i + 1] = qm->xyzs[3 * k1 + 1] + lambda * vn[1];
                pV[3 * i + 2] = qm->xyzs[3 * k1 + 2] + lambda * vn[2];
              }
              vAB[0] = pV[3]  - pV[0]; vAB[1] = pV[4]  - pV[1]; vAB[2] = pV[5]  - pV[2];
              vAC[0] = pV[6]  - pV[0]; vAC[1] = pV[7]  - pV[1]; vAC[2] = pV[8]  - pV[2];
              vAD[0] = pV[9]  - pV[0]; vAD[1] = pV[10] - pV[1]; vAD[2] = pV[11] - pV[2];
              CROSS(vAB, vAC, cross);
              if (DOT(vn, cross) < qEPS) ori[k] = -1;
              else {
                  CROSS(vAC, vAD, cross);
                  if (DOT(vn, cross) < qEPS) ori[k] = -1;
              }
              ma = MAX(ma, ang[k]);
              if ((qm->vType[qV[k]] > 0 && qm->bdAng[qV[k]] > PIEPS) ||
                 (qm->vType[qm->valence[qV[k]][3] - 1] > 0 &&
                  qm->bdAng[qm->valence[qV[k]][3] - 1] > PIEPS)) mba = MAX(mba, ang[k]);
          }
          // Now check if we are creating a sharp angle near domain bounds
          bv[k] = -1;
          if (qm->vType[qV[k]] != -1 || (qm->vType[qm->valence[qV[k]][3] -1] > 0 &&
                                         qm->bdAng[qm->valence[qV[k]][3] -1] > PIEPS)) {
              bv[k] = k;
              if (qm->vType[qV[bv[k]]] == -1)  bvp = MAX (bvp, 1);
              else {
                  bvp = MAX(qm->vType[qV[k]], bvp);
                  if (qm->bdAng[qV[k]] > PIEPS ) {//&& fabs(qm->bdAng[qV[k]] - 2.0 * PI) > qEPS) {
                      // IF QV[k] IS BOUNDARY VERTEX CHECK IF IT CROSSES DOMAIN
                      for (lr[0] = lr[1] = i = 0; i < qm->star[qV[k]]->nQ; i++) {
                          if ( qm->star[qV[k]]->quads[i] == -1) {
                              lr[1] = qm->star[qV[k]]->verts[2 * i + 1]                        - 1;
                              lr[0] = qm->star[qV[k]]->verts[qm->star[qV[k]]->idxV[2 * i + 3]] - 1;
                              break;
                          }
                      }
                      if (lr[1] != qV[(k +1)%4] && lr[0] != qV[(k +3)%4]) {
                          for ( k1 = 1; k1 <= 2; k1++) {
                              vB     = (k + k1    )%4;
                              vC     = (k + k1 + 1)%4;
                              if (qV[vB] == lr[0] || qV[vB] == lr[1] ||
                                  qV[vC] == lr[0] || qV[vC] == lr[1] )continue;
                              vAB[0] = qm->xyzs[3 * qV[vB]    ] - qm->xyzs[3 * qV[k]    ];
                              vAB[1] = qm->xyzs[3 * qV[vB] + 1] - qm->xyzs[3 * qV[k] + 1];
                              vAB[2] = qm->xyzs[3 * qV[vB] + 2] - qm->xyzs[3 * qV[k] + 2];
                              vAC[0] = qm->xyzs[3 * qV[vC]    ] - qm->xyzs[3 * qV[k]    ];
                              vAC[1] = qm->xyzs[3 * qV[vC] + 1] - qm->xyzs[3 * qV[k] + 1];
                              vAC[2] = qm->xyzs[3 * qV[vC] + 2] - qm->xyzs[3 * qV[k] + 2];
                              vAD[0] = qm->xyzs[3 *  lr[0]    ] - qm->xyzs[3 * qV[k]    ];
                              vAD[1] = qm->xyzs[3 *  lr[0] + 1] - qm->xyzs[3 * qV[k] + 1];
                              vAD[2] = qm->xyzs[3 *  lr[0] + 2] - qm->xyzs[3 * qV[k] + 2];
                              CROSS(vAB, vAC, cross);
                              cw = 0;
                              if (DOT(vn, cross) < 0.0 ) cw = 1;
                              // check that BC and CD dont cross the boundary
                              CROSS(vAB, vAD, cross);
                              s1 = s2 = 0;
                              if (DOT(vn, cross) < 0.0) s1 = 1;
                              CROSS(vAD, vAC, cross);
                              if (DOT(vn, cross) < 0.0) s2 = 1;
                              if ((cw == 0 && s1 == 0 && s2 == 0) ||
                              (cw == 1 && s1 == 1 && s2 == 1)) {
                                  selfint = 2;
#ifdef DEBUG
                                  printf(" Alert! QUAD %d LINK %d %d CROSSES THE DOMAIN BOUNDS ! REJECT\n ",
                                  qm->star[vID-1]->quads[s], qV[vB] + 1, qV[vC] + 1);
                                  printf(" LINK AB AL %d %d  %d %d = %d\n ", qV[k] + 1, qV[vB] + 1, qV[k] + 1,  lr[0] + 1, s1);
                                  printf(" LINK AL AC %d %d  %d %d = %d\n ", qV[k] + 1,  lr[0] + 1, qV[k] + 1, qV[vC] + 1, s2);
                                  printQuad(qm, qm->star[vID-1]->quads[s]);
#endif
                                  break;
                              }
                          }
                      }
                  }
              }
          }
          if (ori[k] == -1) continue;
          //if (selfint != 2)
           selfint = 0;
          count++;
      }
      qm->star[vID-1]->angle[s] = ang[0];
      if       (selfint > 0 || count <= 1) qm->star[vID-1]->area[s] = QA3;
      else if (count   != 4) qm->star[vID-1]->area[s] = QA1;
      // now look for special cases: sharp interior corners, boundary quads...
      vr[0] = vr[1] = 0.0;
      qa[0] = tria[0] + tria[2];
      qa[1] = tria[1] + tria[3];
      maiv  = MAX(MAX(ang[iv], ang[(iv+1)%4]), ang[(iv+3)%4]);
      #ifdef DEBUG2
      printf(" ORIS %d %d %d %d\n", ori[0], ori[1], ori[2], ori[3]);
      #endif
      if (doublet == 0 && qa[0] > qEPS && qa[1] > qEPS &&
          qm->star[vID-1]->area[s] <= QA1) {
          k  =  iv    % 2; // id of corresponding diagonal split
          k1 = (iv + 3)%4; // id of triangle with centre iv
          if(tria[k] > qEPS && tria[k + 2] > qEPS)
            vr[0] = MIN(tria[k] / tria[k + 2], tria[k + 2] / tria[k]);
          if(tria[k1] > qEPS && tria[(k1 + 2)%4] > qEPS)
            vr[1] = MIN(tria[k1] / tria[(k1 + 2)%4], tria[(k1 + 2)%4] / tria[k1]);
          if (qm->star[vID-1]->area[s] == QA0) {
              pen = 1.0 - ERF(ANGCUT, 0.5 * ( PI + ANGCUT), maiv); // penalty kicks when angle > ANGCUT
#ifdef DEBUG
              printf(" Angle %lf CUT %lf PENALTY %lf \n", maiv, ANGCUT, pen);
#endif
              if (ang[(iv + 2) %4] > ANGCUT &&
                           ang[iv] < ANGCUT) qm->star[vID-1]->ratio[s] = vr[0];
              else                           qm->star[vID-1]->ratio[s] = MIN(vr[0], vr[1]);
          } else {
              vA = 0;
              if (qa[0] > qa[1] ) vA = 1;
              if (tria[k] + tria [k + 2] > qa[vA]) // MIN AREA = qa[vA]
                qm->star[vID-1]->ratio[s] = -vr[0];
              else if (tria[(k1 + 2)%4] > qEPS &&
                       tria[k1] / tria[(k1 + 2)%4] < 1.0)
                qm->star[vID-1]->ratio[s] = -vr[1];
              else
                qm->star[vID-1]->ratio[s] = vr[0];
          }
      }
      if (selfint == 2 || (selfint == 1 && bvp >= 4) ) qm->star[vID-1]->area[s] = QACB;
      if (qm->star[vID-1]->area[s] >= QA3) qm->star[vID-1]->ratio[s] = -qm->star[vID-1]->angle[s];
      if (doublet == 1) {
          if (qm->star[vID-1]->area [s] < QA3) {
              qm->star[vID-1]->area [s] = QA0;
              qm->star[vID-1]->ratio[s] = 1.0;
          }
      } else if (qm->star[vID-1]->area[s] < QA3 &&
      ((bvp  > 1 && mba  >= PIEPS) ||
      (bvp == 1 && maiv >= PIEPS))) {
#ifdef DEBUG2
          printf(" bvp %d mba %lf maiv %lf\n", bvp, mba, maiv);
#endif
          qm->star[vID-1]->area[s] = bvp * QA2;
      }
      if (qm->star[vID-1]->area [s] ==  QA1 &&
          qm->star[vID-1]->ratio[s] <  -0.5) qm->star[vID-1]->area[s] *= 2;
#ifdef DEBUG2
      if (qm->star[vID-1]->area[s] != QA0) {
          printf("\n\n STAR %d SIGN AREA %d VAL %lf %lf -->RATIO %lf\n",
          vID, qm->star[vID-1]->area[s], qa[0],qa[1],
          qm->star[vID-1]->ratio[s]);
          if (qm->star[vID-1]->area[s] % QA2 == 0 )
              printf(" ************ SHARP CORNER %d = %lf ***************\n", bvp, ma);
          else if (qm->star[vID-1]->area[s] == QA3)
              printf(" ************ SELFINTERSECTS        ***************\n");
          else if (qm->star[vID-1]->area[s] == QACB)
              printf(" ************ CROSSES DOMAIN BOUNDS ***************\n");
          else if (qm->star[vID-1]->area[s] % QA1 == 0)
              printf(" ************ OBTUSE QUAD           ***************\n");
      }
#endif
      qm->star[vID-1]->ratio[s] *= pen;
      if (qm->star[vID-1]->area [s] == QA0 && qm->star[vID-1]->ratio[s] < 1.e-05) {
          qm->star[vID-1]->area [s] = QA1;
          qm->star[vID-1]->ratio[s] = 0.0;
      }
#ifdef DEBUG2
      printf("\n==========  star area %d Q %d BP %d AT V CENTRE %lf=======================\n",
      vID, qm->star[vID-1]->quads[s],  bvp,  qm->star[vID-1]->angle[s]);
      printf(" AREAS %d  penalty %lf ratio %lf\n", qm->star[vID-1]->area[s], pen, qm->star[vID-1]->ratio[s]);
      printf(" ratios TRIS %lf %lf = %lf  %lf %lf = %lf  -- \n ", tria[0], tria[2], vr[0], tria[1], tria[3], vr[1]);
      printf(" Angles (%d = %d) = %lf (%d = %d) = %lf (%d = %d) = %lf (%d = %d) = %lf \n ",
      qV[0] + 1,qm->vType[qV[0]], ang[0], qV[1] + 1, qm->vType[qV[1]],ang[1],
      qV[2] + 1,qm->vType[qV[2]], ang[2], qV[3] + 1, qm->vType[qV[3]],ang[3]);
      printf("\n=================================\n");
#endif
      totArea  += qm->star[vID-1]->area[s];
  }
  return totArea;
}
