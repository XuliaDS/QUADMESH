

static void EG_placeVertex2(meshMap *qm, int vID, double pass, int full) {
    int q, v, j, i, k, i0, i1, ja, jb, qi, update = 0,
            la = -1, lb, nt, block = 0, round, doublet = 0, bt = -1;
    double uv[6], sra[3], srb[3], qr, minb = 0.0;
    int *aArea = NULL, *bArea = NULL;

    minb = MAX(0.25, 1.1 - pass);
#ifdef DEBUG
    char buffer[100];
    int d1, d2;
    double p[2], pos[18];
    FILE *fout;
#endif
    v          = vID - 1;
    if (qm->vType[v] != -1 || qm ->star[v] == NULL) {
#ifdef DEBUG
        printf(" VERTEX %d is boundary star %p!\n ", vID, qm-> star[v]);
#endif
        return;
    }
#ifdef DEBUG
    printf(" Place Coords for vertex %d\n",vID);
    snprintf(buffer, 100,"PLACEStart_%d_%d", qm->plotcount, vID);
    printf("Writing in %s\n ", buffer);
    fout = fopen(buffer,"w");
    if (fout != NULL ) {
        for (d1 = 0; d1 < qm->star[v]->nQ; d1++) {
            p[0] = p[1] = 0.0;
            for (d2 = 0; d2 <= 4; d2++) {
                k = qm->qIdx[ 4 * (qm->star[v]->quads[d1] -1) + d2%4 ] - 1;
                fprintf(fout, "%lf %lf %lf %d\n",  qm->xyzs[3*k  ],
                        qm->xyzs[3*k + 1], qm->xyzs[3*k + 2], k + 1 );
                if ( d2 == 4 ) break;
                p[0] += 0.25 * qm->uvs[2 * k    ];
                p[1] += 0.25 * qm->uvs[2 * k + 1];
            }
            fprintf(fout,"\n\n");
            EG_evaluate(qm->face, p, pos);
            fprintf(fout, "%lf %lf %lf %d\n", pos[0], pos[1], pos[2],
                    qm->star[v]->quads[d1]);
            fprintf(fout,"\n\n");
        }
        fclose (fout);
    }
#endif
    if (qm->valence[v][2] == 2) {
        i0    = qm->valence[v][3] - 1;
        i1    = qm->valence[v][4] - 1;
        uv[0] = 0.5 * (qm->uvs[2 * i0    ] + qm->uvs[2 * i1    ]);
        uv[1] = 0.5 * (qm->uvs[2 * i0 + 1] + qm->uvs[2 * i1 + 1]);
        updateVertex(qm, vID, uv);
#ifdef DEBUG
        printf("PLACE COORD DOUBLET -->LEAVE WITH COORDS\n");
        printVertex(qm, vID);
#endif
        return;
    }
    i0 = i1 = 0;
    for (i = 1 ; i < qm->star[v]->nV; i++) {
        k = qm->vType[qm->star[v]->verts[i] - 1];
        if (k > 0) {
            bt = MAX(bt, k);
            if (i%2 == 0) continue;
            i0++;
            if (k >= 4 && la == -1) la = i;
        } else if (qm -> valence[qm->star[v]->verts[i] - 1][2] == 2) doublet = 1;
    }
    if (i0 >=2 ) bt = 4;
    uv [0] = qm->uvs[2 * v    ];
    uv [1] = qm->uvs[2 * v + 1];
    uv [4] = uv[0];
    uv [5] = uv[1];
    sra[0] = sra[1] = sra[2] = 1.0;
    aArea  = EG_alloc(qm->star[v]->nQ * sizeof(int));
    bArea  = EG_alloc(qm->star[v]->nQ * sizeof (int   ));
    if (aArea == NULL || bArea == NULL) return ;
    for (ja = j = 0 ;j < qm->star[v]->nQ; j++ ) {
        qi  = qm->star[v]->quads[j] -1;
        aArea[j] = EG_quadArea(qm, qi + 1, vID, 1, &qr);
        ja  += aArea[j];
        if (aArea[j] >= QA3) continue;
        if (qr < 0.0) sra[1] = MIN(sra[1], qr);
        else{
            if (qm->vType[qm -> qIdx[4 * qi    ]-1] != -1 ||
                    qm->vType[qm -> qIdx[4 * qi + 1]-1] != -1 ||
                    qm->vType[qm -> qIdx[4 * qi + 2]-1] != -1 ||
                    qm->vType[qm -> qIdx[4 * qi + 3]-1] != -1 )
                sra[2] = MIN(sra[2], qr);
            else sra[0] = MIN(sra[0], qr);
        }
    }
    if (sra[0] > 0.0  && sra[2] > 0.0   &&
        MIN(sra[0], sra[2]) < minb) {
        sra[0] = MIN (sra[0], minb);
        sra[2] = MIN (sra[2], minb);
    }
    srb[0] = srb[1] = srb[2] = 1.0;
    for (round = 0; round <= 2; round++) {
        if (round == 0) {
            nt = qm->star[v]->nQ;
            if (nt %2 == 0) nt /= 2;
        }
        else nt = qm->star[v]->nV;
#ifdef DEBUG
#endif
        for (i1 = i0 = q = 0; q <= nt; q++) {
            if ( pass < 0.0 && q > 0) break;
            uv[2] = uv[0];
            uv[3] = uv[1];
            updateVertex(qm, vID, uv);
#ifdef DEBUG
            printf (" =1=1=11=1=1 ROUND %d  la %d  q %d / %d\n ", round, la, q, nt);
#endif
            block = 0;
            if (q == 0) {
                if (round == 2 ) {
                    if (sra[0] < pass || sra[2] < pass) {
                        EG_centroid(qm, qm->star[v]->nQ,
                                    &qm->valence[v][3],&uv[2], 1);
                        uv[2] = 0.9 * qm->uvs[2 *v    ] + 0.1 * uv[2];
                        uv[3] = 0.9 * qm->uvs[2 *v + 1] + 0.1 * uv[3];
                    }else continue;//EG_centroid(qm, qm->star[v]->nV,
                                     //qm->star[v]->verts,&uv[2], 0);
                } else EG_centroid(qm, qm->star[v]->nQ,
                                  &qm->valence[v][3],&uv[2], (round+2)%2);
            } else if (round == 0) {
                if (qm->star[v]->nQ == 3 ) break;
                i0 = qm->star[v]->verts[2 * (q - 1) + 1] - 1;
                i1 = qm->star[v]->verts[qm->star[v]->idxV[2 * (q - 1) + 5]] - 1;
                j  = qm->star[v]->verts[qm->star[v]->idxV[2 * (q - 1) + 7]] - 1;
                if (j == i0 || qm->vType[i0] * qm->valence[i0][2] == -2 ||
                               qm->vType[i1] * qm->valence[i1][2] == -2 ) continue;
                if ((qm -> vType[i0] > 0 && qm -> vType[i1]  > 0) &&
                     full >= 2) block = 1;
                uv[2] = 0.5 *(qm->uvs[2 * i0    ] + qm->uvs[2 * i1    ]);
                uv[3] = 0.5 *(qm->uvs[2 * i0 + 1] + qm->uvs[2 * i1 + 1]);
            } else if (round == 2) {
                if (q - 1 >= qm->star[v]-> nQ ||
                   (ja == QA0 && (qm->star[v]->nQ == 3 ||
                   (sra[0] > 0.1 && sra[2] > 0.1))))break;
                uv[2] = qm->uvs[2 * v    ];
                uv[3] = qm->uvs[2 * v + 1];
                i1    = 1;
                for (i0 = 0; i0 < qm->star[v]->nQ; i0++) {
                    j = qm->star[v]->verts[2 * i0 + 1] -1;
                    if (i0 == q - 1 || i0 == q ||
                        qm->vType[j] * qm->valence[i][2] == -12) continue;
                    uv[2] += qm->uvs[2 * j];
                    uv[3] += qm->uvs[2 * j + 1];
                    i1++;
                }
                uv[2] /= (double)i1;
                uv[3] /= (double)i1;
#ifdef DEBUG
                printf(" CENTROID EXCLUDING QUAD %d \n",
                       qm->star[v]->quads[q - 1]);
#endif
            } else {
                if (la == -1) break;
                lb = qm->star[v]->idxV [la + q];
#ifdef DEBUG
                printf(" LA %d --> LOOK FOR VERTICES %d ( LB %d)\n ", la, q,
                       qm->star[v]->verts[lb]);
#endif
                if((abs(lb - la) < 3 || abs(lb - la) > nt - 1 - 3 ) ||
                   (ja    == QA0 && sra[0] > 0.1 &&
                    q % 2 == 1   && sra[2] > 0.1))  continue;
                i0 = qm->star[v]->verts[la] - 1;
                i1 = qm->star[v]->verts[lb] - 1;
                if (qm->vType[i1] * qm->valence[i1][2] == -2 ) continue;
                uv[2] = 0.5 *(qm->uvs[2 * i0    ] + qm->uvs[2 * i1    ]);
                uv[3] = 0.5 *(qm->uvs[2 * i0 + 1] + qm->uvs[2 * i1 + 1]);
            }
            updateVertex(qm, vID, &uv[2]);
            srb[0] = srb[1] = srb[2] = 1.0;
            for (jb = j  = 0; j < qm->star[v]->nQ; j++) {
                qi       = qm->star[v]->quads[j] -1;
                bArea[j] = EG_quadArea(qm, qi + 1,vID, 1, &qr);
                jb += bArea[j];
                if (bArea[j] >= QA3) continue;
                if (qr < 0.0) srb[1] = MIN(srb[1], qr);
                else {
                    if (qm->vType[qm -> qIdx[4 * qi    ]-1] != -1 ||
                            qm->vType[qm -> qIdx[4 * qi + 1]-1] != -1 ||
                            qm->vType[qm -> qIdx[4 * qi + 2]-1] != -1 ||
                            qm->vType[qm -> qIdx[4 * qi + 3]-1] != -1 )
                        srb[2]    = MIN(srb[2], qr);
                    else srb[0] = MIN(srb[0], qr);
                }
            }
            if (srb[0] > 0.0 && srb[2] > 0.0 &&
                MIN(srb[0], srb[2]) < minb) {
                srb[0] = MIN (srb[0], minb);
                srb[2] = MIN (srb[2], minb);
            }
#ifdef DEBUG
            if (q == 0 ) printf(" CENTROID %d\n", round);
            else printf("\n\n q - %d / %d MID POINTS BETWEEN %d %d \n ",q ,nt,  i0 + 1, i1 +1);
            printVertex(qm, vID);
            printf(" NOW  AREA %d RATIOS POS %lf NEG %lf QB %lf\n"
                   " BEST AREA %d RATIOS POS %lf NEG %lf QB %lf\n",
                   jb, srb[0], srb[1], srb[2],
                    ja, sra[0], sra[1], sra[2]);
#endif
            k = 0;
#ifdef DEBUG
            printf(" PASS ANGLE %lf  cut %lf QINT %d!!! \n ", pass, minb, bt);
#endif

            if (block ==   1 && (jb != QA0 ||
                srb[0] < 0.1 || srb[2] < 0.1)) block = 0;
            if (qm->star[v]->nQ == 3 && jb == QA0 && q == 0) block = 1;
            if (pass < 0.0 ) {
                if (jb < QA2 ) {
                    block = 2;
                    k = 1;
                }
                else continue;
            }
            if      (block > 0) k = 1;
            else if (jb <  ja) k = 1;
            else if (ja == jb) {
                if (jb < QA3 && (srb[1] < 0.0 || sra[1] < 0.0)) {
                    if (srb[1] < 0.0) {
                        if (sra[1] < 0.0 && srb[1] > sra[1]) k = 1;
                    } else {
                        if      (sra[1] < 0.0) k = 1;
                        else if (
                                 (srb[0] > sra[0] && fabs(srb[0] - sra[0] ) > EPS08) ||
                                 (srb[2] > sra[2] && fabs(srb[2] - sra[2] ) > EPS08))
                            k = 1;
                    }
                }
                else if (jb != QA0 ) {
                    if (srb[0] < EPS08 && sra[0] < EPS08) {
                        if ( srb[2] > sra[2]) k = 1;
                    }
                    else if (srb[2] < EPS08 && sra[2] < EPS08) {
                        if  (srb[0] > sra[0]) k = 1;
                    }
                    else if(MIN(srb[0], srb[2]) > MIN(sra[0], sra[2])) k = 1;
                } else {
                    if (   q == 0  &&
                        //((bt == -1 && srb[0] > 0.1  && srb[2] > 0.1) ||
                         (bt == -1 && srb[0] > pass && srb[2] > pass)) {
                        k     = 1;
                        block = 1;
                    }else if (srb[2] > 0.0) {
                        if (sra[2] < EPS08 ) k = 1;
                        else if (fabs(srb[2] - sra[2]) < EPS08 ) {
                            if (srb[0] > sra[0]) k = 1;
                            else continue;
                        }
                        else if (srb[0] > EPS08) {
                            if (sra[0] < EPS08) k = 1;
                            else {
#ifdef DEBUG
                                printf(" RATIOS B2 / A2 %lf B0 / A0 %lf\n",
                                       srb[2] / sra[2], srb[0] / sra[0]);
                                printf(" RATIOS A2 / B2 %lf A0 / B0 %lf\n",
                                       sra[2] / srb[2], sra[0] / srb[0]);

#endif
                                if (srb[2] > sra[2]) {
                                    if (srb[0] > sra[0] ) k = 1;
                                    else if (srb[2] / sra[2] > sra[0] / srb[0]) k =1 ;
                                    /*if (srb[2] < 0.1 && sra[2] < 0.1 &&
                                        srb[2] / sra[2] > 100.0 &&
                                        srb[2] / sra[2] > srb[0] / sra[0] ) k = 1;*/
                                    else if (srb[2] >= 0.1 && sra[2] < 0.1) k = 1;
                                    else if (sra[0] + srb[0] + sra[2] + srb[2] < 0.01 &&
                                             srb[2] > sra[2]) k = 1;
                                    else continue;
                                }
                                else if (sra[0] > srb[0] ||
                                         (sra[2] >= 0.1 && srb[2] < 0.1)) continue;
                                else if (srb[0] / sra[0] > sra[2] / srb[2] ) k = 1;
                            }
                        }
                        else if (sra[0] > EPS08 ) continue;
                    } else {
                        if (sra[2] > 0.0 || sra[0] > srb[0]) continue;
                        k = 1;
                    }
                }
            }
            if (k == 0) continue;
#ifdef DEBUG
            printf("NEW AREA ja %d jb %d \n", ja,jb);
            printf("A    %lf %lf %lf\n ", sra[0], sra[1], sra[2]);
            printf("BEST %lf %lf %lf\n ", srb[0], srb[1], srb[2]);
#endif
            update = 1;
            uv[4]  = uv[2];
            uv[5]  = uv[3];
            sra[0] = srb[0];
            sra[1] = srb[1];
            sra[2] = srb[2];
            for (j = 0; j < qm->star[v]->nQ; j++) aArea[j] = bArea[j];
            ja = jb;
            if (ja == QA0 && doublet == 1) block = 1;
            else if (block == 1){
#ifdef DEBUG
                printf("BLOCK POSITION QINT %d block %d (pass %lf) src %lf %lf %lf\n",
                       bt, block,pass, srb[0], srb[1], srb[2]);
#endif
                for (jb = i = 0 ; i < qm->star[v] -> nQ; i++ ) {
                    i0 = qm->star[v]-> verts[2 * i + 1];
                    if (qm->vType[i0 - 1] != -1) continue;
                    for ( j = 0 ; j < qm->star[i0-1]->nQ;j++) {
                        jb += EG_quadArea(qm, qm->star[i0-1]->quads[j], i0, 0, &qr);
                        if (jb != QA0 || qr < 0.1) {
#ifdef DEBUG
                            printf(" QUAD %d from vertex %d is area %d\n",
                                   qm->star[i0-1]->quads[j], i0, jb);
#endif
                            break;
                        }
                    }
                    if (jb != QA0 ) {
                        block = 0;
                        break;
                    }
                }
            }
            if (block > 0) break;
        }
        if (block > 0) break;
    }
    if (update == 1) updateVertex(qm, vID, &uv[4]);
    else updateVertex(qm, vID, uv);
#ifdef DEBUG
    snprintf(buffer, 100,"PLACE_%d_%d", qm->plotcount, vID);
    printf("Writing in %s\n ", buffer);
    fout = fopen(buffer,"w");
    if (fout != NULL ) {
	for (d1  = 0; d1 < qm->star[v]->nQ; d1++ ) {
	    p[0] = p[1] = 0.0;
	    for (d2 = 0; d2 <= 4; d2++) {
		k   = qm->qIdx[ 4 * (qm->star[v]->quads[d1] -1) + d2%4 ] - 1;
		fprintf(fout, "%lf %lf %lf %d\n",  qm->xyzs[3*k  ],
			qm->xyzs[3*k + 1], qm->xyzs[3*k + 2], k + 1 );
		if (d2 == 4) break;
		p[0] += 0.25 * qm->uvs[2 * k    ];
		p[1] += 0.25 * qm->uvs[2 * k + 1];
	    }
	    fprintf(fout,"\n\n");
	    EG_evaluate(qm->face, p, pos);
	    fprintf(fout, "%lf %lf %lf %d\n", pos[0], pos[1], pos[2],
		    qm->star[v]->quads[d1]);
	    fprintf(fout,"\n\n");
	}
	fclose (fout);
    }
#endif
    EG_free(bArea);
    EG_free(aArea);
    return;
}

