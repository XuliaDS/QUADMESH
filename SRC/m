 static int EG_vertexArea(meshMap *qm, int vID)
  {
   int s, i, stat, k, k1, vA, vB, vC, vD, count, doublet, qV[4], ori[4], bv[4], lr[2], iv = -1, bvp;
   int selfint = 1, cw, s1, s2, totArea = 0, epsuv = 0, ta, tb, td;
   double pQ[12], cross[3],vn[6], vAB[3], vAC[3], vAD[3], nXYZ[18], xyz[18], tria[8], vr[2], uv[2];
   double ango, c, dotNP, lambda, norm1, norm2, ang[4], dot, qa[2], pen = 1.0, ma = 0.0, maiv = 0.0,mba = 0.0, fact;

   for (s = 0; s < qm->star[vID-1]->nQ; s++) {
       qm->star[vID-1]->area [s]    = QA0;
       qm->star[vID-1]->ratio[s]    = 1.0;
       qm->star[vID-1]->angle[s]    = PI * 0.5;
       if(qm->star[vID-1]->quads[s] == -1) continue;
       dot = EG_quadSize(qm, qm->star[vID-1]->quads[s], tria );
 #ifdef DEBUG2
       printf(" TRIAREAS %lf %lf  %lf  %lf  \n", tria[0], tria[2], tria[1], tria[3]);
 #endif
       qV[0] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 )    ] - 1;
       qV[1] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 1] - 1;
       qV[2] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 2] - 1;
       qV[3] = qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) + 3] - 1;
       // project coordinates
       selfint =  1;
       iv      = -1;
       mba     = ma = maiv = 0.0;
       bvp     = 0;
       for (doublet = count = k = 0; k < 4; ++k) {
           ori [k]  =  1;
           ang [k]  =  0.0;
           bv  [k]  = -1;
           if (qV[k] + 1 == vID) iv = k;
           if ( qm->vType[qV[k]] != -1 ||
               (qm->vType[qm->valence[qV[k]][3] -1] > 0 &&
                qm->bdAng[qm->valence[qV[k]][3] -1] > PIEPS)) bv[k] = k;
           if (qm->valence[qV[k]][2] * qm->vType[qV[k]] == -2) {
               ori[k]  = 1;
               doublet = 1;
           } else {
               vA    =  k;
               vB    = (k + 1)%4;
               vC    = (k + 2)%4;
               vD    = (k + 3)%4;
               ta = MIN(qm-> vType[qV[vA]], 0);
               tb = MIN(qm-> vType[qV[vB]], 0);
               td = MIN(qm-> vType[qV[vD]], 0);
               if (ta == 0 && qm->degen[qV[vA]] == 1) ta++;
               if (tb == 0 && qm->degen[qV[vB]] == 1) tb++;
               if (td == 0 && qm->degen[qV[vD]] == 1) td++;

               if (EG_angAtNPlane(qm, qV[vA] + 1, qV[vB] + 1, qV[vD] + 1,
                                  vn, &ang[k]) != EGADS_SUCCESS ) return QA0;
              c      = vn[0] * vn[3] + vn[1] * vn[4] + vn[2] * vn[5];
              vAB[0] = qm->xyzs[3 *qV[vB]    ] - qm->xyzs[3 *qV[vA]    ];
              vAB[1] = qm->xyzs[3 *qV[vB] + 1] - qm->xyzs[3 *qV[vA] + 1];
              vAB[2] = qm->xyzs[3 *qV[vB] + 2] - qm->xyzs[3 *qV[vA] + 2];
              vAC[0] = qm->xyzs[3 *qV[vC]    ] - qm->xyzs[3 *qV[vA]    ];
              vAC[1] = qm->xyzs[3 *qV[vC] + 1] - qm->xyzs[3 *qV[vA] + 1];
              vAC[2] = qm->xyzs[3 *qV[vC] + 2] - qm->xyzs[3 *qV[vA] + 2];
              vAD[0] = qm->xyzs[3 *qV[vD]    ] - qm->xyzs[3 *qV[vA]    ];
              vAD[1] = qm->xyzs[3 *qV[vD] + 1] - qm->xyzs[3 *qV[vA] + 1];
              vAD[2] = qm->xyzs[3 *qV[vD] + 2] - qm->xyzs[3 *qV[vA] + 2];
              CROSS(vAB, vAC, cross);
              if (DOT(vn, cross) < qEPS) ori[k] = -1;
              else {
                 CROSS(vAC, vAD, cross);
                 if (DOT(vn, cross) < qEPS) ori[k] = -1;
              }
              ma = MAX(ma, ang[k]);
              if ((qm->vType[qV[k]] > 0 && qm->bdAng[qV[k]] > PIEPS) ||
                  (qm->vType[qm->valence[qV[k]][3] - 1] > 0 &&
                   qm->bdAng[qm->valence[qV[k]][3] - 1] > PIEPS)) mba = MAX(mba, ang[k]);
           }
           if (ori[k] == -1) continue;
           selfint = 0;
           count++;
       }
       qm->star[vID-1]->angle[s] = ang[iv];
       if      (selfint == 1) qm->star[vID-1]->area[s] = QA3;
       else if (count   != 4) qm->star[vID-1]->area[s] = QA1;
       // now look for special cases: sharp interior corners, boundary quads...
       vr[0] = vr[1] = 0.0;
       qa[0] = tria[0] + tria[2];
       qa[1] = tria[1] + tria[3];
       maiv  = MAX(MAX(ang[iv], ang[(iv+1)%4]), ang[(iv+3)%4]);
       if (doublet == 0 && qa[0] > qEPS && qa[1] > qEPS &&
           qm->star[vID-1]->area[s] <= QA1) {
           k  =  iv    % 2; // id of corresponding diagonal split
           k1 = (iv + 3)%4; // id of triangle with centre iv
           if(tria[k] > qEPS && tria[k + 2] > qEPS)
             vr[0] = MIN(tria[k] / tria[k + 2], tria[k + 2] / tria[k]);
           if(tria[k1] > qEPS && tria[(k1 + 2)%4] > qEPS)
             vr[1] = MIN(tria[k1] / tria[(k1 + 2)%4], tria[(k1 + 2)%4] / tria[k1]);
           if (qm->star[vID-1]->area[s] == QA0) {
               pen = 1.0 - ERF(ANGCUT, 0.5 * ( PI + ANGCUT), maiv); // penalty kicks when angle > ANGCUT
 #ifdef DEBUG
               printf(" Angle %lf CUT %lf PENALTY %lf \n", maiv, ANGCUT, pen);
 #endif
               if (ang[(iv + 2) %4] > ANGCUT &&
                            ang[iv] < ANGCUT) qm->star[vID-1]->ratio[s] = vr[0];
               else                               qm->star[vID-1]->ratio[s] = MIN(vr[0], vr[1]);
           } else {
               vA = 0;
               if (qa[0] > qa[1] ) vA = 1;
               if (tria[k] + tria [k + 2] > qa[vA]) // MIN AREA = qa[vA]
                 qm->star[vID-1]->ratio[s] = -vr[0];
               else if (tria[(k1 + 2)%4] > qEPS &&
                        tria[k1] / tria[(k1 + 2)%4] < 1.0)
                 qm->star[vID-1]->ratio[s] = -vr[1];
               else
                 qm->star[vID-1]->ratio[s] = vr[0];
           }
       }
       for (k = 0 ; k < 4; k++) {
           if (bv[k] == -1 ) continue;
           if (qm->vType[qV[bv[k]]] == -1) {
               bvp = MAX (bvp, 1);
               continue;
           }
           bvp = MAX(qm->vType[qV[k]], bvp);
           if (qm->bdAng[qV[k]] < PIEPS) continue;
           // check if we cross the domain boundary. This can happen even for valid quads!!
           for (lr[0] = lr[1] = i = 0; i < qm->star[qV[k]]->nQ; i++) {
               k1 = qm->star[qV[k]]->verts[2 * i + 1] - 1;
               if ( qm->star[qV[k]]->quads[i] == -1) {
                   lr[1] = qm->star[qV[k]]->verts[2 * i + 1] - 1;
                   lr[0] = qm->star[qV[k]]->verts[qm->star[qV[k]]->idxV[2 * i + 3]] - 1;
                   break;
               }
           }
           EG_centroid(qm, 4, &qm->qIdx[4 * (qm->star[vID-1]->quads[s] - 1 ) ], uv, 0);
           stat  = EG_evaluate(qm->face, uv, nXYZ);
           norm1 = nXYZ[3] * nXYZ[3] + nXYZ[4] * nXYZ[4] + nXYZ[5] * nXYZ[5];
           norm2 = nXYZ[6] * nXYZ[6] + nXYZ[7] * nXYZ[7] + nXYZ[8] * nXYZ[8];
           norm1 = sqrt(norm1 * norm2);
           if (norm1 < qEPS || stat != EGADS_SUCCESS) continue;
           vAB[0] = nXYZ[3]; vAB[1] = nXYZ[4]; vAB[2] = nXYZ[5];
           vAC[0] = nXYZ[6]; vAC[1] = nXYZ[7]; vAC[2] = nXYZ[8];
           if (qm->face->mtype == SREVERSE) {
               CROSS(vAC, vAB,vn);
           } else {
               CROSS(vAB, vAC,vn);
           }
          vn[0] /= norm1;
          vn[1] /= norm1;
          vn[2] /= norm1;
           c           = DOT(vn, nXYZ);
           for (i = 0; i < 4; i++) {
               dotNP            =vn[0] * qm->xyzs[3 * qV[i]    ] +
                                 vn[1] * qm->xyzs[3 * qV[i] + 1] +
                                 vn[2] * qm->xyzs[3 * qV[i] + 2];
               lambda           = (c - dotNP);
               pQ[3 * i    ] = qm->xyzs[3 * qV[i]    ] + lambda *vn[0];
               pQ[3 * i + 1] = qm->xyzs[3 * qV[i] + 1] + lambda *vn[1];
               pQ[3 * i + 2] = qm->xyzs[3 * qV[i] + 2] + lambda *vn[2];
           }
           dotNP  =vn[0] * qm->xyzs[3 * lr[0]    ] +
                   vn[1] * qm->xyzs[3 * lr[0] + 1] +
                   vn[2] * qm->xyzs[3 * lr[0] + 2];
           lambda = (c - dotNP);
           xyz[0] = qm->xyzs[3 * lr[0]    ] + lambda *vn[0];
           xyz[1] = qm->xyzs[3 * lr[0] + 1] + lambda *vn[1];
           xyz[2] = qm->xyzs[3 * lr[0] + 2] + lambda *vn[2];
           if (k != (iv + 2)%4) {
               dotNP  =vn[0] * qm->xyzs[3 * lr[1]    ] +
                       vn[1] * qm->xyzs[3 * lr[1] + 1] +
                       vn[2] * qm->xyzs[3 * lr[1] + 2];
               lambda = (c - dotNP);
               xyz[3] = qm->xyzs[3 * lr[1]    ] + lambda *vn[0];
               xyz[4] = qm->xyzs[3 * lr[1] + 1] + lambda *vn[1];
               xyz[5] = qm->xyzs[3 * lr[1] + 2] + lambda *vn[2];
               vAB[0] = xyz[0] - pQ[3 * k    ];
               vAB[1] = xyz[1] - pQ[3 * k + 1];
               vAB[2] = xyz[2] - pQ[3 * k + 2];
               vAC[0] = xyz[3] - pQ[3 * k    ];
               vAC[1] = xyz[4] - pQ[3 * k + 1];
               vAC[2] = xyz[5] - pQ[3 * k + 2];
               CROSS(vAB, vAC, cross);
               norm1 = sqrt(DOT(vAB, vAB) * DOT(vAC, vAC));
               if (norm1 < qEPS ) dot = 1.0;
               else dot = DOT(vAB, vAC) / norm1;
               if      (fabs(dot - 1.0) < EPS08) dot = 0.0;
               else if (fabs(dot + 1.0) < EPS08) dot = PI;
               else                              dot = acos(dot);
               if (DOT(vn, cross) < 0.0)    dot = (2.0 * PI - dot);
               if (dot > PIEPS) bvp = MAX(4, bvp);
               if (ang[k] > ANGCUT ) {
                   mba = MAX(mba, ang[k]);
 #ifdef DEBUG
                   printf(" ANGLE AT BOUND %d IS %lf  MBA %lf PASS %lf\n", qV[k], dot, mba, ANGCUT);
 #endif
               }
           }
           if (lr[1] == qV[(k +1)%4] ||
               lr[0] == qV[(k +3)%4]) continue;
           for ( k1 = 1; k1 <= 2; k1++) {
               vB     = (k + k1    )%4;
               vC     = (k + k1 + 1)%4;
               if (qV[vB] == lr[0] || qV[vB] == lr[1] ||
                   qV[vC] == lr[0] || qV[vC] == lr[1] )continue;
               vAB[0] = pQ[3*vB    ] - pQ[3 * k    ];
               vAB[1] = pQ[3*vB + 1] - pQ[3 * k + 1];
               vAB[2] = pQ[3*vB + 2] - pQ[3 * k + 2];
               vAC[0] = pQ[3*vC    ] - pQ[3 * k    ];
               vAC[1] = pQ[3*vC + 1] - pQ[3 * k + 1];
               vAC[2] = pQ[3*vC + 2] - pQ[3 * k + 2];
               vAD[0] = xyz[0]       - pQ[3 * k    ];
               vAD[1] = xyz[1]       - pQ[3 * k + 1];
               vAD[2] = xyz[2]       - pQ[3 * k + 2];
               CROSS(vAB, vAC, cross);
               cw = 0;
               if (DOT(vn, cross) < 0 ) cw = 1;
               // check that BC and CD dont cross the boundary
               CROSS(vAB, vAD, cross);
 			  s1 = s2 = 0;
 			  if (DOT(vn, cross) < 0.0) s1 = 1;
               CROSS(vAD, vAC, cross);
               if (DOT(vn, cross) < 0.0) s2 = 1;
               norm1   = DOT(vAC, vAC);
               if ((cw == 0 && s1 == 0 && s2 == 0) ||
                   (cw == 1 && s1 == 1 && s2 == 1)) {
                   selfint = 2;
 #ifdef DEBUG
                   printf(" Alert! QUAD %d LINK %d %d CROSSES THE DOMAIN BOUNDS ! REJECT\n ",
                                                             qm->star[vID-1]->quads[s], qV[vB] + 1, qV[vC] + 1);
                   printf(" LINK AB AL %d %d  %d %d = %d\n ", qV[k] + 1, qV[vB] + 1, qV[k] + 1,  lr[0] + 1, s1);
                   printf(" LINK AL AC %d %d  %d %d = %d\n ", qV[k] + 1,  lr[0] + 1, qV[k] + 1, qV[vC] + 1, s2);
                   printQuad(qm, qm->star[vID-1]->quads[s]);
 #endif
                   break;
               }
           }
           if (selfint == 2) break;
       }
       if (selfint == 2 || (selfint == 1 && bvp >= 4) ) qm->star[vID-1]->area[s] = QACB;
       if (qm->star[vID-1]->area[s] >= QA3) qm->star[vID-1]->ratio[s] = -qm->star[vID-1]->angle[s];
       if (doublet == 1) {
           if (qm->star[vID-1]->area [s] < QA3) {
               qm->star[vID-1]->area [s] = QA0;
               qm->star[vID-1]->ratio[s] = 1.0;
           }
       } else if (qm->star[vID-1]->area[s] < QA3 &&
       ((bvp  > 1 && mba  >= PIEPS) ||
       (bvp == 1 && maiv >= PIEPS))) {
 #ifdef DEBUG2
           printf(" bvp %d mba %lf maiv %lf\n", bvp, mba, maiv);
 #endif
           qm->star[vID-1]->area[s] = bvp * QA2;
       }
       if (qm->star[vID-1]->area [s] ==  QA1 &&
           qm->star[vID-1]->ratio[s] <  -0.5) qm->star[vID-1]->area[s] *= 2;
 #ifdef DEBUG2
       if (qm->star[vID-1]->area[s] != QA0) {
           printf("\n\n STAR %d SIGN AREA %d VAL %lf %lf -->RATIO %lf\n",
           vID, qm->star[vID-1]->area[s], qa[0],qa[1],
           qm->star[vID-1]->ratio[s]);
           if (qm->star[vID-1]->area[s] % QA2 == 0 )
               printf(" ************ SHARP CORNER %d = %lf ***************\n", bvp, ma);
           else if (qm->star[vID-1]->area[s] == QA3)
               printf(" ************ SELFINTERSECTS        ***************\n");
           else if (qm->star[vID-1]->area[s] == QACB)
               printf(" ************ CROSSES DOMAIN BOUNDS ***************\n");
           else if (qm->star[vID-1]->area[s] % QA1 == 0)
               printf(" ************ OBTUSE QUAD           ***************\n");
       }
 #endif
       qm->star[vID-1]->ratio[s] *= pen;
       if (qm->star[vID-1]->area [s] == QA0 && qm->star[vID-1]->ratio[s] < 1.e-05) {
           qm->star[vID-1]->area [s] = QA1;
           qm->star[vID-1]->ratio[s] = 0.0;
       }
 #ifdef DEBUG2
       printf("\n==========  star area %d Q %d BP %d AT V CENTRE %lf=======================\n",
       vID, qm->star[vID-1]->quads[s],  bvp,  qm->star[vID-1]->angle[s]);
       printf(" AREAS %d  penalty %lf ratio %lf\n", qm->star[vID-1]->area[s], pen, qm->star[vID-1]->ratio[s]);
       printf(" ratios TRIS %lf %lf = %lf  %lf %lf = %lf  -- \n ", tria[0], tria[2], vr[0], tria[1], tria[3], vr[1]);
       printf(" Angles (%d) = %lf (%d) = %lf (%d) = %lf (%d) = %lf \n ",
       qV[0] + 1, ang[0], qV[1] + 1, ang[1],
       qV[2] + 1, ang[2], qV[3] + 1, ang[3]);
       printf("\n=================================\n");
 #endif
       totArea  += qm->star[vID-1]->area[s];
   }
   return totArea;
 }
